# Chapter 1

We first load our utilities, which contains the `eq` procedure for simple
testing.

    (load "../lib/util.scm")


## 1.1

[Exercise 1.1](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_thm_1.1)

    10                    ; 10

    (+ 5 3 4)             ; 12

    (- 9 1)               ; 8

    (/ 6 2)               ; 3

    (+ (* 2 4) (- 4 6))   ; 6

    (define a 3)          ; a

    (define b (+ a 1))    ; b

    (+ a b (* a b))       ; 19

    (= a b)               ; #f

    (if (and (> b a)      ; 4
             (< b (* a b))) b a)

The expression returns a value of `4`.  The consequent `b` is evaluated and returned since the predicate/condition is true.

    (cond ((= a 4) 6)           ; #f
          ((= b 4) (+ 6 7 a))   ; #t -> 6 + 7 + 3 = 16
          (else 25))

The expression returns a value of `16`.  The second predicate/condition is true, so the corresponding consequent expression `(+ 6 7 a)` is evaluated and returned.

    (+ 2 (if (> b a) b a))      ; 6

The expression evaluates to `6` since `b > a`. 

    (* (cond ((> a b) a)        ; #f
             ((< a b) b)        ; #t -> 4
             (else -1))
       (+ a 1))                 ; 4

The expression evaluates to `16`.


## 1.2

Translate the following expression into prefix form:

`[ 5 + 4 + (2 - (3 - (6 + 4/5))) ] / [ 3 * (6 - 2) * (2 - 7) ]`

    (eq (/ -37 150)
        (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))  ; 74/5
           (* 3 (- 6 2) (- 2 7))))            ; -60

    (eq (/ -37 150)
        (/ (/ 74 5) -60)) 


## 1.3

Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.

    (define (square x) (* x x))

    ; return two largest numbers
    (define (largest-2 x y z)
      (if (> x y) (cons x (cons (if (> y z) y z) '()))
                  (cons y (cons (if (> x z) x z) '()))))

    ; sum the squares of the two largest numbers
    (define (sum-of-sq x y z)
      (+ (square (car (largest-2 x y z))) 
         (square (cadr (largest-2 x y z)))))

    (eq (sum-of-sq 2 3 4) 25)
    (eq (sum-of-sq 2 4 3) 25)
    (eq (sum-of-sq 3 4 2) 25)
    (eq (sum-of-sq 3 2 4) 25)
    (eq (sum-of-sq 4 3 2) 25)
    (eq (sum-of-sq 4 2 3) 25)


## 1.4

Observe that our model of evaluation allows for combinations whose operators are compound expressions.  Use this observation to describe the behavior of the following procedure:

    (define (a-plus-abs-b a b)
      ((if (> b 0) + -) a b))

    (eq 4 (a-plus-abs-b 2 2))
    (eq 6 (a-plus-abs-b 2 4))
    (eq 4 (a-plus-abs-b 2 -2))
    (eq 6 (a-plus-abs-b 2 -4))

The predicate `(if (> b 0) + -)` evaluates to the appropriate operator based on the
value of the procedure's second argument `b`. In other words, we can express
our operators conditionally, varying which operators are used in the procedure
based on runtime conditions.


## 1.5

We want to determine whether our interpreter's evaluation order, **applicative** or **normal**.  Consider the following two procedures:

    (define (p) (p))

    (define (test x y)
      (if (= x 0)
          0
          y))

Now consider what happens when we evaluate the expression `(test 0 (p))`.

(Assume that the evaluation rule for the special form `if` is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)

Explain the different behavior we'll observe under the two different evaluation strategies.

Applicative-order evaluation will ...

Normal-order evaluation will ...

## 1.9

Each of the following two procedures defines a method for adding two positive integers in terms of the procedures `inc`, which increments its argument by 1, and `dec`, which decrements its argument by 1.

    (define (+ a b)
      (if (= a 0)
          b
          (inc (+ (dec a) b))))

    (define (+ a b)
      (if (= a 0)
          b
          (+ (dec a) (inc b))))

Using the substitution model, illustrate the process generated by each procedure in evaluating `(+ 4 5)`. Are these processes iterative or recursive?


## 1.10.  

The following procedure computes a mathematical function called Ackermann's function.

    (define (A x y)
      (cond ((= y 0) 0)
            ((= x 0) (* 2 y))
            ((= y 1) 2)
            (else (A (- x 1)
                    (A x (- y 1))))))

What are the values of the following expressions?

    (A 1 10)

    (A 2 4)

    (A 3 3)

Consider the following procedures, where A is the procedure defined above:

(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))

Give concise mathematical definitions for the functions computed by the procedures f, g, and h for positive integer values of n. For example, (k n) computes 5n2.



