# Chapter 1

We first load our utilities, which contains the `eq` procedure for simple
testing.

    (load "../lib/util.scm")


## 1.1

[Exercise 1.1](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_thm_1.1)

    10                    ; 10

    (+ 5 3 4)             ; 12

    (- 9 1)               ; 8

    (/ 6 2)               ; 3

    (+ (* 2 4) (- 4 6))   ; 6

    (define a 3)          ; a

    (define b (+ a 1))    ; b

    (+ a b (* a b))       ; 19

    (= a b)               ; #f

    (if (and (> b a)      ; 4
             (< b (* a b))) b a)

The expression returns a value of `4`.  The consequent `b` is evaluated and returned since the predicate/condition is true.

    (cond ((= a 4) 6)           ; #f
          ((= b 4) (+ 6 7 a))   ; #t -> 6 + 7 + 3 = 16
          (else 25))

The expression returns a value of `16`.  The second predicate/condition is true, so the corresponding consequent expression `(+ 6 7 a)` is evaluated and returned.

    (+ 2 (if (> b a) b a))      ; 6

The expression evaluates to `6` since `b > a`. 

    (* (cond ((> a b) a)        ; #f
             ((< a b) b)        ; #t -> 4
             (else -1))
       (+ a 1))                 ; 4

The expression evaluates to `16`.


## 1.2

Translate the following expression into prefix form:

`[ 5 + 4 + (2 - (3 - (6 + 4/5))) ] / [ 3 * (6 - 2) * (2 - 7) ]`

    (eq (/ -37 150)
        (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))  ; 74/5
           (* 3 (- 6 2) (- 2 7))))            ; -60

    (eq (/ -37 150)
        (/ (/ 74 5) -60)) 


## 1.3

Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.

    (define (square x) (* x x))

    ; return two largest numbers
    (define (largest-2 x y z)
      (if (> x y) (cons x (cons (if (> y z) y z) '()))
                  (cons y (cons (if (> x z) x z) '()))))

    ; sum the squares of the two largest numbers
    (define (sum-of-sq x y z)
      (+ (square (car (largest-2 x y z))) 
         (square (cadr (largest-2 x y z)))))

    (eq (sum-of-sq 2 3 4) 25)
    (eq (sum-of-sq 2 4 3) 25)
    (eq (sum-of-sq 3 4 2) 25)
    (eq (sum-of-sq 3 2 4) 25)
    (eq (sum-of-sq 4 3 2) 25)
    (eq (sum-of-sq 4 2 3) 25)


## 1.4

Observe that our model of evaluation allows for combinations whose operators are compound expressions.  Use this observation to describe the behavior of the following procedure:

    (define (a-plus-abs-b a b)
      ((if (> b 0) + -) a b))

    (eq 4 (a-plus-abs-b 2 2))
    (eq 6 (a-plus-abs-b 2 4))
    (eq 4 (a-plus-abs-b 2 -2))
    (eq 6 (a-plus-abs-b 2 -4))

The predicate `(if (> b 0) + -)` evaluates to the appropriate operator based on the
value of the procedure's second argument `b`. In other words, we can express
our operators conditionally, varying which operators are used in the procedure
based on runtime conditions.


## 1.5

We want to determine whether our interpreter's evaluation order, **applicative** or **normal**.  Consider the following two procedures:

    (define (p) (p))

    (define (test x y)
      (if (= x 0)
          0
          y))

Now consider what happens when we evaluate the expression `(test 0 (p))`.

(Assume that the evaluation rule for the special form `if` is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)

Explain the different behavior we'll observe under the two different evaluation strategies.

Applicative-order evaluation will ...

Normal-order evaluation will ...

## 1.9


Each of the following two procedures defines a method for adding two positive
integers in terms of the procedures `++`, which increments its argument by 1,
and `--`, which decrements its argument by 1.

Using the substitution model, illustrate the process generated by each procedure 
in evaluating `(+ 4 5)`. Are these processes iterative or recursive?

We first define the increment (`++`) and decrement (`--`) operations.

    ; increment by one
    (define (++ x)
      ; (pp (cons '++ (cons x '())))
      (+ x 1))

    ; decrement by one
    (define (-- x)
      ; (pp (cons '-- (cons x '())))
      (- x 1))

We use these methods in the definition of `sum`.

    (define (sum a b)
      (if (= a 0)
          b
          (++ (sum (-- a) b))))

This is an example of a recursive process with nested execution calls. Note how
the process builds up a chain of deferred operations.

    ; (sum 4 5)
    ; (++ (sum (-- 4) 5)
    ;     (++ (sum (-- 3) 5)
    ;         (++ (sum (-- 2) 5)
    ;             (++ (sum (-- 1) 5)
    ;             (++ 5)
    ;         (++ 6)
    ;     (++ 7)
    ; (++ 8)
    ; 9

    (define (sum a b)
      (if (= a 0)
          b
          (sum (-- a) (++ b))))

This is an example of a iterative process where each execution call is
indepedent of its predecessor. Recall that "an iterative process is one whose
state can be summarized by a fixed number of state variables, together with a
fixed rule that describes how the state variables should be updated as the
process moves from state to state and an (optional) end test that specifies the
condition(s) under which the process should terminate."

Note that the state of the overall computation is captured completely by its state
variables. The interpreter need only update the procedure's state variables to execute 
the process.

    ; (sum 4 5)
    ; (sum 3 6)
    ; (sum 2 7)
    ; (sum 1 8)
    ; (sum 0 9)
    ; 9


## 1.10.  

The following procedure computes a mathematical function called Ackermann's function.

    (define (A x y)
      (cond ((= y 0) 0)
            ((= x 0) (* 2 y))
            ((= y 1) 2)
            (else (A (- x 1)
                    (A x (- y 1))))))

What are the values of the following expressions?

    (A 1 10)  ; 1024

    (A 2 4)   ; 65536

    (A 3 3)   ; 65536

Consider the following procedures, where `A` is the procedure defined above.  Give concise mathematical definitions for the functions computed by the
procedures `f`, `g`, and `h` for positive integer values of *n*. 

First ...

    (define (f n) (A 0 n))

    ; closed form solution
    (define (_f n) (* 2 n))

The closed form solution follows immediately from the definition of Ackermann's
function, viz. the second condition.

Next ...

    (define (g n) (A 1 n))

    ; (g 0) => 0
    ; (g 1) => 2
    ; (g 2) => (A 0 (A 1 1))
    ;               2
    ;          (A 0 2)            ... see definition of `_f` above
    ;          4

    ; (g 3) => (A 0 (A 1 2))
    ;               (A 0 (A 1 1))
    ;                    2
    ;               (A 0 2)
    ;          (A 0 (* 2 2))      ... see definition of `_f` above
    ;          (A 0 4)
    ;          (* 2 4)
    ;          8

    ; (g 4) => 16     = 2^4
    ; (g 5) => 32     = 2^5
    ; (g 6) => 64     = 2^6

    ; closed form solution
    (define (_g n) (expt 2 n))

Finally ...

    (define (h n) (A 2 n))

    ; (h 0)   => 0
    ; (A 2 0) => 0

    ; (h 1)   => 2
    ; (A 2 1) => 2      2^1   2^(2^0)

    ; (h 2)   => 4
    ; (A 2 2) => 4      2^2   2^(2^1)

    ; (h 3)   => 16
    ; (A 2 3) => 16     2^4   2^(2^2)

    ; (h 4)   => 65536
    ; (A 2 4) => 65536  2^16  2^(2^(2^2))

    (define (_h n) 
      (cond ((= n 0) 0)
            ((= n 1) 2)
            (else (expt 2 (_h (- n 1))))))

    (define (^ x y) (expt x y))

    (define (^^ x y) 
      (cond ((= y 0) 0)
            ((= y 1) x)
            (else (expt x (^^ x (- y 1))))))

We could of course combine the various procedure definitions defined above to
create a more computationally effecient version of Ackermann's functions for
the specific conditions each of the above procedures is designed to handle.

    (define (B x y)
      (cond ((= y 0) 0)
            ((= x 0) (* 2 y))
            ((= x 1) (^ 2 y))
            ((= x 2) (^^ 2 y))))

    (eq (A 2 1) 
        (B 2 1))

    (eq (A 2 3)
        (B 2 3))

